[2017-01-17 Tue] parah, baru gw look over lagi. nov 2016 udah diskusi dengan
pian bahwa vulnerable (eh tapi waktu itu ngecek kayaknya gak vulnerable pake POD
dirtyc0w.c, tapi sekarang pake POC yang dirty.c dari FireFart bisa). trus
diprotek dengan ulimit -t 180 lalu dipendekin jadi -t 120. tapi ternyata bbrp
hari lalu arieibrahim priv message di forum bahwa kernel squeeze kena [ternyata
gw tes kadang 1 menit lebih sedikit juga udah bisa berhasil exploitnya]. squeeze
kernelnya 2.6.32-5, gak diupdate2x lagi oleh debian sejak mei 2014 termasuk
untuk vulnerability ini. sekitar 3 menit di server seperti gold untuk dapat
root.

masalahnya, gak ada patch buat 2.6.32. original patchnya dari sini:
https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619

#+BEGIN_SRC c
diff --git a/include/linux/mm.h b/include/linux/mm.h
index e9caec6..ed85879 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2232,6 +2232,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,
 #define FOLL_TRIED	0x800	/* a retry, previous pass started an IO */
 #define FOLL_MLOCK	0x1000	/* lock present pages */
 #define FOLL_REMOTE	0x2000	/* we are working on non-current tsk/mm */
+#define FOLL_COW	0x4000	/* internal GUP flag */

 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);
diff --git a/mm/gup.c b/mm/gup.c
index 96b2b2f..22cc22e 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -60,6 +60,16 @@ static int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,
 	return -EEXIST;
 }

+/*
+ * FOLL_FORCE can write to even unwritable pte's, but only
+ * after we've gone through a COW cycle and they are dirty.
+ */
+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
+{
+	return pte_write(pte) ||
+		((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
+}
+
 static struct page *follow_page_pte(struct vm_area_struct *vma,
 		unsigned long address, pmd_t *pmd, unsigned int flags)
 {
@@ -95,7 +105,7 @@ retry:
 	}
 	if ((flags & FOLL_NUMA) && pte_protnone(pte))
 		goto no_page;
-	if ((flags & FOLL_WRITE) && !pte_write(pte)) {
+	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {
 		pte_unmap_unlock(ptep, ptl);
 		return NULL;
 	}
@@ -412,7 +422,7 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 	 * reCOWed by userspace write).
 	 */
 	if ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))
-		*flags &= ~FOLL_WRITE;
+	        *flags |= FOLL_COW;
 	return 0;
 }
#+END_SRC

gw coba bikin yang mirip2x hasilnya seperti ini:

#+BEGIN_SRC c
--- a/include/linux/mm.h        2009-12-03 03:51:21.000000000 +0000
+++ b/include/linux/mm.h        2017-01-17 09:38:22.999985791 +0000
@@ -1239,6 +1239,7 @@
 #define FOLL_GET       0x04    /* do get_page on page */
 #define FOLL_DUMP      0x08    /* give error on hole if it would be zero */
 #define FOLL_FORCE     0x10    /* get_user_pages read/write w/o permission */
+#define FOLL_COW       0x4000  /* internal GUP flag */

 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
                        void *data);

--- a/mm/memory.c       2009-12-03 03:51:21.000000000 +0000
+++ b/mm/memory.c       2017-01-17 09:48:28.819860747 +0000
@@ -1125,6 +1125,16 @@
 EXPORT_SYMBOL_GPL(zap_vma_ptes);

 /*
+ * FOLL_FORCE can write to even unwritable pte's, but only
+ * after we've gone through a COW cycle and they are dirty.
+ */
+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
+{
+       return pte_write(pte) ||
+               ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
+}
+
+/*
  * Do a quick page-table lookup for a single page.
  */
 struct page *follow_page(struct vm_area_struct *vma, unsigned long address,
@@ -1176,7 +1186,7 @@
        pte = *ptep;
        if (!pte_present(pte))
                goto no_page;
-       if ((flags & FOLL_WRITE) && !pte_write(pte))
+       if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags))
                goto unlock;

        page = vm_normal_page(vma, address, pte);
@@ -1353,7 +1363,7 @@
                                 */
                                if ((ret & VM_FAULT_WRITE) &&
                                    !(vma->vm_flags & VM_WRITE))
-                                       foll_flags &= ~FOLL_WRITE;
+                                       foll_flags |= FOLL_COW;

                                cond_resched();
                        }
#+END_SRC

untuk mencoba patch ini, ada skrip di paket kernel debian
(debian/bin/test-patches). bisa dilihat di sini cara pakainya:

https://kernel-handbook.alioth.debian.org/ch-common-tasks.html

cuma cepet jadinya 11 menit di mesin gold, ketimbang gw pake cara manual yaitu
edit debian/changelog, taruh patch di debian/patches/bugfix/all/ lalu bikin
debian/patches/series/48squeeze7. jadinya lama banget, 1,5 jam juga gak kelar2x
karena utk 1 arch bikin berbagai flavor (486, 686) ditambah lagi featureset
seperti xen, openvz, ...

dan... yes!!! patch ini berhasil. exploitnya exit tapi gak berhasil ganti
/etc/passwd. mo gw suruh ade dan pian coba ke mesin squeeze.
